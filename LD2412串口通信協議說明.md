# LD2412 雷達傳感器串口通信協議詳細說明

## ⚠️ 重要修正通知

🚨 **v2.6 關鍵修正**: 門敏感度查詢回應解析格式已修正！
- **門0敏感度位於回應數據的第10字節位置**，不是之前誤認為的保留字節
- 此修正解決了門0敏感度被錯誤顯示的重大問題
- 請更新您的解析代碼以使用正確的位置偏移量

## 📡 協議概述

LD2412是一款24GHz毫米波雷達傳感器，支持透過串口UART進行配置和數據獲取。本文檔詳細說明其通信協議格式和命令集。

## 🔧 通信參數

| 參數 | 設定值 | 說明 |
|------|--------|------|
| **波特率** | 256000 bps (預設) | 支援9600-460800多種波特率 |
| **數據位** | 8 bit | 固定 |
| **停止位** | 1 bit | 固定 |
| **校驗位** | None | 無校驗 |
| **流控制** | None | 無流控制 |

### 支援的波特率
- 9600 bps
- 19200 bps
- 38400 bps
- 57600 bps
- **115200 bps** (常用)
- 230400 bps
- **256000 bps** (預設)
- 460800 bps

## 📦 數據幀格式

LD2412使用兩種幀格式：**數據幀**和**命令幀**

### 1. 工程模式數據幀格式 (感測器數據輸出)

```
幀頭     長度   類型 校驗  目標狀態  移動目標數據    靜止目標數據    距離門能量數據              光感  保留  尾部  保留  幀尾
F4F3F2F1 LLLL   01   AA    SS       DDDD EE        DDDD EE        [移動門能量][靜止門能量]    LL    RR    55    RR    F8F7F6F5
4字節    2字節  1字節 1字節 1字節    3字節          3字節          14+14字節                  1字節  1字節  1字節  1字節  4字節
```

#### 工程模式數據幀結構詳解
| 位置 | 字節數 | 名稱 | 說明 |
|------|--------|------|------|
| 0-3 | 4 | 幀頭 | `F4 F3 F2 F1` (固定) |
| 4-5 | 2 | 數據長度 | 小端序，不含幀頭幀尾 |
| 6 | 1 | 數據類型 | `01` (工程模式) |
| 7 | 1 | 校驗字節 | 通常為 `AA` | 
| 8 | 1 | **目標狀態** | 見狀態位解析 |
| 9-10 | 2 | 移動目標距離 | 單位CM，小端序 |
| 11 | 1 | 移動目標能量值 | 0-100 |
| 12-13 | 2 | 靜止目標距離 | 單位CM，小端序 |
| 14 | 1 | 靜止目標能量值 | 0-100 |
| 15 | 1 | **移動能量門數量** | `0D` (13，代表0-13共14門) |
| 16 | 1 | **靜止能量門數量** | `0D` (13，代表0-13共14門) |
| 17-30 | 14 | 移動距離門0-13能量值 | 每門0-100 |
| 31-44 | 14 | 靜止距離門0-13能量值 | 每門0-100 |
| 45 | 1 | **光感數據** | 光感傳感器值 (0x00-0xFF) |
| 46 | 1 | 保留字節1 | - |
| 47 | 1 | 尾部標識 | 固定 `55` |
| 48 | 1 | 保留字節2 | - |
| 49-52 | 4 | 幀尾 | `F8 F7 F6 F5` (固定) |

### 2. 一般模式數據幀格式

```
幀頭     長度   類型 校驗  目標狀態  移動目標數據    靜止目標數據    尾部  保留  幀尾
F4F3F2F1 LLLL   02   AA    SS       DDDD EE        DDDD EE        55    RR    F8F7F6F5
4字節    2字節  1字節 1字節 1字節    3字節          3字節          1字節  1字節  4字節
```

#### 一般模式數據幀結構詳解
| 位置 | 字節數 | 名稱 | 說明 |
|------|--------|------|------|
| 0-3 | 4 | 幀頭 | `F4 F3 F2 F1` (固定) |
| 4-5 | 2 | 數據長度 | 小端序，不含幀頭幀尾 |
| 6 | 1 | 數據類型 | `02` (一般模式) |
| 7 | 1 | 校驗字節 | 通常為 `AA` | 
| 8 | 1 | **目標狀態** | 見狀態位解析 |
| 9-10 | 2 | 移動目標距離 | 單位CM，小端序 |
| 11 | 1 | 移動目標能量值 | 0-100 |
| 12-13 | 2 | 靜止目標距離 | 單位CM，小端序 |
| 14 | 1 | 靜止目標能量值 | 0-100 |
| 15 | 1 | 尾部標識 | 固定 `55` |
| 16 | 1 | 保留字節 | - |
| 17-20 | 4 | 幀尾 | `F8 F7 F6 F5` (固定) |

### 3. 命令幀格式 (配置命令)

```
幀頭     長度   命令碼      命令數據           幀尾
FDFCFBFA LLLL  CCCC       [數據...]         04030201
4字節    2字節  2字節      變長              4字節
```

#### 命令幀結構詳解
| 位置 | 字節數 | 名稱 | 說明 |
|------|--------|------|------|
| 0-3 | 4 | 幀頭 | `FD FC FB FA` (固定) |
| 4-5 | 2 | 數據長度 | 小端序，不含幀頭幀尾 |
| 6-7 | 2 | 命令碼 | 小端序，見命令表 |
| 8+ | 變長 | 命令數據 | 依命令而定 |
| -4--1 | 4 | 幀尾 | `04 03 02 01` (固定) |

## 🎯 數據類型與狀態解析

### 數據類型
| 值 | 說明 |
|----|------|
| `0x01` | 工程模式數據 |
| `0x02` | 目標基本信息數據 |

### 目標狀態位解析
| 值 | 二進制 | 說明 |
|----|--------|------|
| `0x00` | `00000000` | 無目標 |
| `0x01` | `00000001` | 運動目標 |
| `0x02` | `00000010` | 靜止目標 |
| `0x03` | `00000011` | 運動&靜止目標 |
| `0x04` | `00000100` | 正在底噪檢測中 |
| `0x05` | `00000101` | 底噪檢測成功 |
| `0x06` | `00000110` | 底噪檢測失敗 |


## ⚙️ 配置參數詳細說明

用戶可通過LD2412的串口給模組修改配置參數，來適應不同的應用需求。

### 1. 最大距離門

**作用**: 設置最遠探測距離，只有在此最遠距離內出現的人體目標才會被探測到並輸出結果。

**設定方式**:
- 以距離門為單位進行設置，每個距離門為0.75m
- 可設置範圍為1～13
- 例如設置最遠距離門為2，則只有在1.5m內有人體存在才會有效探測到並輸出結果

**距離門對照表**:
| 距離門號 | 實際距離 | 距離門號 | 實際距離 |
|----------|----------|----------|----------|
| 門1 | 0.75m | 門8 | 6.0m |
| 門2 | 1.5m | 門9 | 6.75m |
| 門3 | 2.25m | 門10 | 7.5m |
| 門4 | 3.0m | 門11 | 8.25m |
| 門5 | 3.75m | 門12 | 9.0m |
| 門6 | 4.5m | 門13 | 9.75m |
| 門7 | 5.25m | - | - |

### 2. 最小距離門

**作用**: 設置最近探測距離，到雷達模組大於此距離的人體目標才會被探測到並輸出結果。

**設定方式**:
- 以距離門為單位進行設置，每個距離門為0.75m
- 可設置範圍為1～13
- 例如設置最近距離門為2，則只有到雷達模組的距離大於1.5m的人體才會有效探測到並輸出結果

**應用場景**:
- 避免雷達模組附近的干擾
- 設定盲區，排除過近距離的誤觸發
- 適應特定安裝環境的需求

### 3. 靈敏度設定

**作用**: 探測到的目標能量值(範圍0～100)大於靈敏度值時才會判定為目標存在，否則忽略。

**設定特點**:
- 靈敏度值可設置範圍：0～100
- **每個距離門可獨立設置靈敏度**
- 可對不同距離範圍內的探測進行精準調節
- 支援局部精準探測或對特定區域干擾源的過濾

**特殊用法**:
- 將某個距離門的靈敏度設置為100時，可達到**不識別此距離門下目標**的效果
- 例如：將距離門3和距離門4的靈敏度設置為20，其他距離門的靈敏度都設置為100，則可實現**僅對距離模組2.25～3.75m範圍內的人體進行探測**

**靈敏度調節建議**:
| 環境類型 | 建議靈敏度 | 說明 |
|----------|------------|------|
| 安靜環境 | 15-30 | 高靈敏度，檢測微小動作 |
| 一般環境 | 30-50 | 平衡靈敏度與穩定性 |
| 嘈雜環境 | 50-80 | 降低誤觸發 |
| 特定區域屏蔽 | 100 | 完全屏蔽該距離門 |

### 4. 無人持續時間（無人延時）

**作用**: 雷達在輸出從有人到無人的結果中，會持續一段時間上報有人。

**工作原理**:
- 若在此時間段雷達測試範圍內持續無人，雷達上報無人
- 若在此時間段雷達檢測到有人，則重新刷新此時間
- 相當於無人延時時間，人離開後，保持無人超過此持續時間後才會輸出狀態為無人

**設定參數**:
- 單位：秒
- 最小值：5秒
- 建議範圍：5-60秒

**應用場景**:
| 應用場景 | 建議時間 | 說明 |
|----------|----------|------|
| 照明控制 | 30-60秒 | 避免頻繁開關燈 |
| 安防監控 | 5-15秒 | 快速響應入侵 |
| 空調控制 | 60-300秒 | 節能考慮 |
| 會議室檢測 | 15-30秒 | 平衡響應與穩定 |

### 5. 配置參數組合應用範例

#### 範例1: 會議室人員檢測
```
最大距離門: 8 (6米範圍)
最小距離門: 1 (0.75米起始)
靈敏度: 門1-3設為40, 門4-8設為25
無人持續時間: 30秒
用途: 檢測會議室內人員，避免桌椅干擾
```

#### 範例2: 走廊通道檢測
```
最大距離門: 6 (4.5米範圍)
最小距離門: 2 (1.5米起始，避免雷達附近干擾)
靈敏度: 所有門設為35
無人持續時間: 15秒
用途: 走廊照明自動控制
```

#### 範例3: 特定區域監控
```
最大距離門: 10 (7.5米範圍)
最小距離門: 4 (3米起始)
靈敏度: 門1-3設為100(屏蔽), 門4-7設為20, 門8-10設為100(屏蔽)
無人持續時間: 10秒
用途: 僅監控3-5.25米特定區域
```

## 📋 命令集與回應說明

### 1. 基本控制命令

#### 進入配置模式
```
發送: FD FC FB FA 04 00 FF 00 01 00 04 03 02 01
回應: FD FC FB FA 08 00 FF 01 00 00 01 00 00 00 04 03 02 01
說明: 必須先進入配置模式才能執行配置命令

回應數據格式:
- 第1-2字節: ACK狀態 (00 00 = 成功)
- 第3-4字節: 協議版本 (01 00 = v1.0)
- 第5-6字節: 保留字段 (00 00)
```

#### 退出配置模式
```
發送: FD FC FB FA 02 00 FE 00 04 03 02 01
回應: FD FC FB FA 04 00 FE 01 00 00 04 03 02 01
說明: 退出配置模式，恢復正常運行
```

#### 查詢參數（兼數據輸出啟動）
```
發送: FD FC FB FA 02 00 12 00 04 03 02 01
回應: FD FC FB FA 09 00 12 01 00 00 [參數數據] 04 03 02 01
說明: 查詢當前設定參數，同時啟動數據輸出

參數數據格式 (5字節):
- 第1字節: 最小距離門 (1-13)
- 第2字節: 最大距離門 (1-13) 
- 第3-4字節: 無人持續時間 (單位秒，小端序)
- 第5字節: OUT腳輸出極性 (0=有人輸出高電平, 1=有人輸出低電平)

範例回應: FD FC FB FA 09 00 12 01 00 00 01 0C 05 00 00 04 03 02 01
解析: 最小門=1, 最大門=12, 超時=5秒, OUT腳有人輸出高電平
```

### 2. 查詢命令

#### 查詢版本信息
```
發送: FD FC FB FA 02 00 A0 00 04 03 02 01
回應: FD FC FB FA 0B 00 A0 01 00 00 [版本數據] 04 03 02 01

版本數據格式 (8字節):
- 第1-2字節: 韌體類型 (0x1224 = LD2412)
- 第3-4字節: 主版本號 (小端序)
- 第5-8字節: 次版本號 (小端序)

範例回應: FD FC FB FA 0B 00 A0 01 00 00 12 24 10 01 10 18 04 24 04 03 02 01
解析: 韌體類型0x2412, 主版本1.16, 次版本24041810
完整版本號: V1.16.24041810
```

#### 查詢距離分辨率
```
發送: FD FC FB FA 02 00 11 00 04 03 02 01
回應: FD FC FB FA 0A 00 11 01 00 00 [分辨率數據] 04 03 02 01

分辨率數據格式 (6字節):
- 第1字節: 分辨率值
- 第2-6字節: 保留 (固定為0x00)

分辨率對照表:
| 值 | 分辨率 | 最大範圍 |
|----|--------|----------|
| 0x00 | 75cm/距離門 | 12米 |
| 0x01 | 50cm/距離門 | 8米 |
| 0x03 | 20cm/距離門 | 3.2米 |

範例回應: FD FC FB FA 0A 00 11 01 00 00 01 00 00 00 00 00 04 03 02 01
解析: 分辨率為50cm/距離門
```

#### 查詢MAC地址
```
發送: FD FC FB FA 04 00 A5 00 01 00 04 03 02 01
回應: FD FC FB FA 08 00 A5 01 [6字節MAC] 04 03 02 01
範例: 1B 61 6B B4 2A A0 = MAC地址 1B:61:6B:B4:2A:A0
```

#### 查詢背景校正狀態
```
發送: FD FC FB FA 02 00 1B 00 04 03 02 01
回應: FD FC FB FA 06 00 1B 01 00 00 [狀態數據] 04 03 02 01

狀態數據格式 (2字節):
- 0x0000: 未在執行動態背景校正
- 0x0001: 正在執行動態背景校正中

範例回應: FD FC FB FA 06 00 1B 01 00 00 01 00 04 03 02 01
解析: 正在執行動態背景校正中
```

### 3. 系統控制命令

#### 重啟模組
```
發送: FD FC FB FA 02 00 A3 00 04 03 02 01
回應: FD FC FB FA 04 00 A3 01 00 00 04 03 02 01
說明: 軟件重啟LD2412模組，重啟後需重新初始化
```

#### 恢復出廠設定
```
發送: FD FC FB FA 02 00 A2 00 04 03 02 01
回應: FD FC FB FA 04 00 A2 01 00 00 04 03 02 01
說明: 清除所有用戶設定，恢復預設值，配置值在重啟模組後生效
```

**出廠默認配置值**:
| 配置項 | 默認值 | 說明 |
|--------|--------|------|
| **最小距離門** | 1 | 0.75m起始檢測距離 |
| **最大距離門** | 14 | 10.5m最大檢測距離 |
| **無人持續時間** | 5秒 | 最小延時時間 |
| **串口波特率** | 115200 bps | 標準通信速率 |
| **距離分辨率** | 0.75m | 預設分辨率模式 |
| **光感輔助控制** | 關閉 | 預設不啟用光感控制 |

#### 藍牙控制
```
開啟藍牙:
發送: FD FC FB FA 04 00 A4 00 01 00 04 03 02 01
回應: FD FC FB FA 04 00 A4 01 00 00 04 03 02 01

關閉藍牙:
發送: FD FC FB FA 04 00 A4 00 00 00 04 03 02 01
回應: FD FC FB FA 04 00 A4 01 00 00 04 03 02 01
```

### 4. 配置命令 (需先進入配置模式)

#### 設定距離分辨率
```
發送: FD FC FB FA 08 00 01 00 [分辨率數據] 04 03 02 01
回應: FD FC FB FA 04 00 01 01 00 00 04 03 02 01
說明: 更改此設置後需要重啟模組才能生效

分辨率數據格式 (6字節):
- 第1字節: 分辨率值
- 第2-6字節: 固定為0x00

分辨率設置範例:
0.75米分辨率 (12米範圍):
發送: FD FC FB FA 08 00 01 00 00 00 00 00 00 00 04 03 02 01

0.5米分辨率 (8米範圍):
發送: FD FC FB FA 08 00 01 00 01 00 00 00 00 00 04 03 02 01

0.2米分辨率 (3.2米範圍):
發送: FD FC FB FA 08 00 01 00 03 00 00 00 00 00 04 03 02 01
```

#### 基礎參數配置
```
發送: FD FC FB FA 07 00 02 00 [參數數據] 04 03 02 01
回應: FD FC FB FA 04 00 02 01 00 00 04 03 02 01
說明: 配置雷達基礎參數，配置值掉電不丟失

參數數據格式 (5字節):
- 第1字節: 最小距離門 (1-13)
- 第2字節: 最大距離門 (1-13)
- 第3-4字節: 無人持續時間 (單位秒，小端序)
- 第5字節: OUT腳輸出極性 (0=有人輸出高電平, 1=有人輸出低電平)

範例: 設置最小門=1, 最大門=12, 超時=5秒, OUT腳有人輸出高電平
發送: FD FC FB FA 07 00 02 00 01 0C 05 00 00 04 03 02 01
```

**OUT腳輸出極性說明**:
- **0x00**: 有人輸出高電平 (3.3V)，無人輸出低電平 (0V)
- **0x01**: 有人輸出低電平 (0V)，無人輸出高電平 (3.3V)
- **應用**: 適配不同的外部電路需求，如繼電器控制、LED指示等

#### 運動靈敏度配置
```
發送: FD FC FB FA 10 00 03 00 [敏感度數據] 04 03 02 01
回應: FD FC FB FA 04 00 03 01 00 00 04 03 02 01
說明: 配置各距離門運動靈敏度，配置值掉電不丟失

敏感度數據格式 (14字節):
- 14字節敏感度值，每字節對應門0-13的運動敏感度 (0-100)

範例: 設置門0-2為35，門3-13為25
發送: FD FC FB FA 10 00 03 00 00 23 23 23 19 19 19 19 19 19 19 19 19 19 04 03 02 01
```

#### 靜止靈敏度配置
```
發送: FD FC FB FA 10 00 04 00 [敏感度數據] 04 03 02 01
回應: FD FC FB FA 04 00 04 01 00 00 04 03 02 01
說明: 配置各距離門靜止靈敏度，配置值掉電不丟失

敏感度數據格式 (14字節):
- 14字節敏感度值，每字節對應門0-13的靜止敏感度 (0-100)

範例: 設置門0-2為35，門3-13為25
發送: FD FC FB FA 10 00 04 00 00 23 23 23 19 19 19 19 19 19 19 19 19 19 04 03 02 01
```

#### 設定最大距離和超時
```
發送: FD FC FB FA 14 00 60 00 [參數數據] 04 03 02 01
回應: FD FC FB FA 04 00 60 01 00 00 04 03 02 01

參數結構 (18字節):
- [最大移動距離] (2字節，小端序，單位CM)
- [最大靜止距離] (2字節，小端序，單位CM) 
- [超時時間] (2字節，小端序，單位秒)

範例: 設定8米最大距離，10秒超時
發送: FD FC FB FA 08 00 60 00 20 03 20 03 0A 00 04 03 02 01
解析: 移動800cm，靜止800cm，超時10秒
```

#### 設定門檻值
```
發送: FD FC FB FA 20 00 64 00 [門檻數據] 04 03 02 01
回應: FD FC FB FA 04 00 64 01 00 00 04 03 02 01

門檻數據格式 (28字節):
- [移動門檻值] (14字節，門0-13的敏感度0-100)
- [靜止門檻值] (14字節，門0-13的敏感度0-100)
```

#### 設定波特率
```
發送: FD FC FB FA 04 00 A1 00 [波特率碼] 00 04 03 02 01
回應: FD FC FB FA 04 00 A1 01 00 00 04 03 02 01
說明: 設置模組串口波特率，配置值掉電不丟失，配置值在重啟模組後生效

波特率對照表:
| 碼值 | 波特率 | 說明 |
|------|--------|------|
| 0x01 | 9600 | 低速模式 |
| 0x02 | 19200 | 低速模式 |
| 0x03 | 38400 | 標準模式 |
| 0x04 | 57600 | 標準模式 |
| **0x05** | **115200** | **出廠默認值** |
| 0x06 | 230400 | 高速模式 |
| 0x07 | 256000 | 高速模式 |
| 0x08 | 460800 | 高速模式 |

範例: 設置波特率為256000 bps
發送: FD FC FB FA 04 00 A1 00 07 00 04 03 02 01
```

#### 動態背景校正
```
發送: FD FC FB FA 02 00 0B 00 04 03 02 01
回應: FD FC FB FA 04 00 0B 01 00 00 04 03 02 01
說明: 進入動態背景校正模式，模組收到指令後10秒後開始執行校正
```

**動態背景校正詳細說明**:
- **執行時機**: 發送命令後10秒開始校正過程
- **執行時間**: 校正過程約需2分鐘完成
- **校正期間**: 上報數據幀中的目標狀態值會指示當前校正狀態
- **狀態指示**: 參考目標狀態位解析 (0x04=檢測中, 0x05=成功, 0x06=失敗)
- **自動保存**: 校正成功後將自動儲存配置至模組
- **環境要求**: 校正期間請保持檢測區域無人員活動

#### 光感輔助控制功能設定
```
發送: FD FC FB FA 04 00 0C 00 [控制字節] [光感閾值] 04 03 02 01
回應: FD FC FB FA 04 00 0C 01 00 00 04 03 02 01
說明: 配置光感輔助控制功能，影響OUT腳輸出邏輯
```

**功能說明**:
本模組自帶光敏二極管，可用來檢測輸出光感值（參考工程模式數據幀）。用戶可配置開啟光感輔助控制功能。

**OUT腳輸出邏輯**:
開啟光感輔助控制功能後，OUT腳的輸出同時受雷達檢測結果和光感輔助控制邏輯的影響：
- **OUT腳輸出從無人變為有人**: 需要滿足雷達檢測到有人**且**光感輔助控制邏輯條件滿足
- **OUT腳輸出從有人變為無人**: 只需要滿足雷達檢測到無人

**配置參數說明**:

| 第一個字節 | 功能說明 |
|------------|----------|
| `0x00` | 關閉光感輔助控制功能，OUT腳輸出不受光感影響 |
| `0x01` | 開啟光感輔助控制功能，當檢測光感值**小於**設置閾值時輔助控制條件滿足 |
| `0x02` | 開啟光感輔助控制功能，當檢測光感值**大於**設置閾值時輔助控制條件滿足 |

| 第二個字節 | 說明 |
|------------|------|
| `0x00～0xFF` | 要設置的光感閾值(範圍0～255)，出廠預設為0x00 |

**應用範例**:
```
範例1: 開啟光感輔助控制（光線不足時觸發）
發送: FD FC FB FA 04 00 0C 00 01 50 04 03 02 01
說明: 當光感值小於0x50(80)時，輔助控制條件滿足
用途: 只在光線較暗時才啟動照明控制

範例2: 開啟光感輔助控制（光線充足時觸發）  
發送: FD FC FB FA 04 00 0C 00 02 80 04 03 02 01
說明: 當光感值大於0x80(128)時，輔助控制條件滿足
用途: 只在有足夠光線時才觸發其他設備

範例3: 關閉光感輔助控制
發送: FD FC FB FA 04 00 0C 00 00 00 04 03 02 01
說明: 關閉光感輔助控制，OUT腳僅受雷達檢測影響
```

**光感輔助控制應用場景**:
| 應用場景 | 建議配置 | 說明 |
|----------|----------|------|
| 智能照明 | 模式0x01，閾值50-100 | 光線不足時才開燈 |
| 白天/夜間模式切換 | 模式0x01，閾值80-120 | 根據光線自動切換模式 |
| 節能控制 | 模式0x02，閾值100-150 | 光線充足時才工作 |
| 窗簾自動控制 | 模式0x02，閾值60-100 | 有陽光時自動調節 |

#### 查詢光感輔助控制功能配置
```
發送: FD FC FB FA 02 00 1C 00 04 03 02 01
回應: FD FC FB FA 06 00 1C 01 00 00 [配置數據] 04 03 02 01

配置數據格式 (2字節):
- 第1字節: 控制模式 (同設定命令的第一個字節)
  - 0x00: 關閉光感輔助控制功能
  - 0x01: 光感值小於閾值時輔助控制條件滿足
  - 0x02: 光感值大於閾值時輔助控制條件滿足
- 第2字節: 光感閾值 (0x00-0xFF)

範例回應: FD FC FB FA 06 00 1C 01 00 00 02 A0 04 03 02 01
解析: 模式0x02(光感值大於閾值觸發)，閾值0xA0(160)
```

### 5. 工程模式控制

#### 進入工程模式
```
發送: FD FC FB FA 02 00 62 00 04 03 02 01
回應: FD FC FB FA 04 00 62 01 00 00 04 03 02 01
說明: 切換到工程模式，獲得詳細門檻數據
```

#### 退出工程模式  
```
發送: FD FC FB FA 02 00 63 00 04 03 02 01
回應: FD FC FB FA 04 00 63 01 00 00 04 03 02 01
說明: 切換回一般模式
```

#### 查詢移動門敏感度
```
發送: FD FC FB FA 02 00 13 00 04 03 02 01
回應: FD FC FB FA 12 00 13 01 00 00 [敏感度數據] 04 03 02 01
說明: 查詢每個距離門的運動靈敏度

敏感度數據格式 (16字節):
- 第1字節: 執行狀態 (01 = 成功)
- 第2字節: ACK狀態 (00 = 成功)
- 第3字節: 門0敏感度值 (0-100)
- 第4-16字節: 門1-13敏感度值 (0-100)

重要修正: 門0敏感度位於第3字節位置，不是保留字節！

範例回應: FD FC FB FA 12 00 13 01 00 00 00 23 23 23 19 19 19 19 19 19 19 19 19 19 04 03 02 01
正確解析: 執行成功(01), ACK成功(00), 門0=0(0x00), 門1=35(0x23), 門2=35(0x23), 門3=35(0x23), 門4-13=25(0x19)

常見錯誤: 將第3字節誤認為保留字節，導致門0敏感度解析為門1的值
```

#### 查詢靜止門敏感度
```
發送: FD FC FB FA 02 00 14 00 04 03 02 01
回應: FD FC FB FA 12 00 14 01 00 00 [敏感度數據] 04 03 02 01
說明: 查詢每個距離門的靜止靈敏度

敏感度數據格式 (16字節):
- 第1字節: 執行狀態 (01 = 成功)
- 第2字節: ACK狀態 (00 = 成功)
- 第3字節: 門0敏感度值 (0-100)
- 第4-16字節: 門1-13敏感度值 (0-100)

重要修正: 門0敏感度位於第3字節位置，不是保留字節！

範例回應: FD FC FB FA 12 00 14 01 00 00 00 64 0F 0F 0F 0F 0F 0F 0F 0F 0F 0F 0F 0F 04 03 02 01
正確解析: 執行成功(01), ACK成功(00), 門0=0(0x00), 門1=100(0x64), 門2-13=15(0x0F)

實際案例分析:
根據實際測試數據 FD FC FB FA 12 00 14 01 00 00 00 64 23 19 0F...
- 第8字節(01): 執行成功
- 第9字節(00): ACK成功  
- 第10字節(00): 門0敏感度 = 0 (正確)
- 第11字節(64): 門1敏感度 = 100
- 第12字節以後: 門2-13敏感度值

此修正解決了門0敏感度被錯誤顯示為100的問題！
```

## 🔧 命令回應格式解析

### 回應幀結構
所有命令回應都遵循以下格式：
```
幀頭     長度   命令碼   狀態   回應數據           幀尾
FDFCFBFA LLLL  CCCC    01     [數據...]         04030201
4字節    2字節  2字節   1字節   變長              4字節
```

### 回應解析規則
1. **命令碼**: 第6字節是回應的命令碼，與發送命令相同
2. **狀態字節**: 第7字節通常為0x01表示成功
3. **數據長度**: 第4-5字節包含除幀頭幀尾外的總長度
4. **回應數據**: 從第8字節開始的實際回應內容

### 常用回應狀態
- `0x01`: 命令執行成功
- `0x00`: 命令執行失敗或不支援

## ⚙️ 常用操作流程

### 1. 標準初始化序列
```python
# 標準初始化流程
def initialize_ld2412():
    # 1. 進入配置模式
    send_command("FD FC FB FA 04 00 FF 00 01 00 04 03 02 01")
    wait_for_ack("FD FC FB FA 04 00 FF 01 00 00 04 03 02 01")
    
    # 2. 查詢版本 (可選)
    send_command("FD FC FB FA 02 00 A0 00 04 03 02 01") 
    version_response = wait_for_response()
    
    # 3. 退出配置模式
    send_command("FD FC FB FA 02 00 FE 00 04 03 02 01")
    wait_for_ack("FD FC FB FA 04 00 FE 01 00 00 04 03 02 01")    

```

### 2. 工程模式完整流程
```python
def enable_engineering_mode():
    # 1. 進入配置模式
    send_command("FD FC FB FA 04 00 FF 00 01 00 04 03 02 01")
    wait_for_ack("FD FC FB FA 04 00 FF 01 00 00 04 03 02 01")
    
    # 2. 進入工程模式
    send_command("FD FC FB FA 02 00 62 00 04 03 02 01")
    wait_for_ack("FD FC FB FA 04 00 62 01 00 00 04 03 02 01")
    
    # 3. 退出配置模式
    send_command("FD FC FB FA 02 00 FE 00 04 03 02 01") 
    wait_for_ack("FD FC FB FA 04 00 FE 01 00 00 04 03 02 01")
    
    # 4. 查詢敏感度設定
    send_command("FD FC FB FA 02 00 13 00 04 03 02 01")  # 移動門敏感度
    send_command("FD FC FB FA 02 00 14 00 04 03 02 01")  # 靜止門敏感度

```

### 3. 完整設備診斷流程
```python
def device_diagnostics():
    # 1. 進入配置模式
    send_command("FD FC FB FA 04 00 FF 00 01 00 04 03 02 01")
    
    # 2. 查詢所有設定
    send_command("FD FC FB FA 02 00 A0 00 04 03 02 01")   # 版本
    send_command("FD FC FB FA 04 00 A5 00 01 00 04 03 02 01")  # MAC
    send_command("FD FC FB FA 02 00 11 00 04 03 02 01")   # 距離分辨率
    send_command("FD FC FB FA 02 00 12 00 04 03 02 01")   # 參數
    send_command("FD FC FB FA 02 00 1B 00 04 03 02 01")   # 背景校正狀態
    
    # 3. 查詢門敏感度
    send_command("FD FC FB FA 02 00 13 00 04 03 02 01")   # 移動門敏感度
    send_command("FD FC FB FA 02 00 14 00 04 03 02 01")   # 靜止門敏感度
    
    # 4. 退出配置模式
    send_command("FD FC FB FA 02 00 FE 00 04 03 02 01")
```

## 🔧 調試工具函數

### 1. 數據幀驗證
```python
import struct

def validate_data_frame(frame):
    """驗證數據幀格式"""
    # 檢查最小長度
    if len(frame) < 21:
        return False, "幀長度不足"
    
    # 檢查幀頭
    if frame[:4] != b'\xF4\xF3\xF2\xF1':
        return False, "幀頭錯誤"
    
    # 檢查幀尾
    if frame[-4:] != b'\xF8\xF7\xF6\xF5':
        return False, "幀尾錯誤"
    
    # 檢查長度字段
    declared_length = struct.unpack('<H', frame[4:6])[0]
    actual_length = len(frame) - 8  # 減去幀頭幀尾
    if declared_length != actual_length:
        return False, f"長度不匹配: 聲明{declared_length}, 實際{actual_length}"
        
    return True, "驗證通過"

def validate_command_response(frame):
    """驗證命令回應幀格式"""
    # 檢查最小長度
    if len(frame) < 12:
        return False, "命令幀長度不足"
    
    # 檢查幀頭
    if frame[:4] != b'\xFD\xFC\xFB\xFA':
        return False, "命令幀頭錯誤"
    
    # 檢查幀尾
    if frame[-4:] != b'\x04\x03\x02\x01':
        return False, "命令幀尾錯誤"
        
    return True, "命令幀驗證通過"
```

### 2. 狀態解析
```python
def parse_target_state(state_byte):
    """解析目標狀態字節"""
    return {
        'target_exists': bool(state_byte & 0x01),
        'moving_target': bool(state_byte & 0x02),
        'still_target': bool(state_byte & 0x04),
        'detecting_noise': bool(state_byte & 0x04),
        'noise_detect_success': state_byte == 0x05,
        'noise_detect_failed': state_byte == 0x06,
        'state_code': state_byte
    }
```

### 3. 命令回應解析
```python
def parse_command_response(frame):
    """解析命令回應幀"""
    validation_result = validate_command_response(frame)
    if not validation_result[0]:
        return None, validation_result[1]
    
    data_length = frame[4] | (frame[5] << 8)
    command_code = frame[6] | (frame[7] << 8)  # 修正：使用小端序解析命令碼
    status_byte = frame[8] if len(frame) > 8 else 0   # 修正：第8字節是狀態
    
    result = {
        'frame_length': len(frame),
        'data_length': data_length,
        'command_code': command_code,
        'status': status_byte,
        'success': status_byte == 0x01,
        'response_data': frame[8:-4] if len(frame) > 12 else b''
    }
    
    # 特殊命令解析
    if command_code == 0xA0:  # 版本查詢
        if len(result['response_data']) >= 10:  # 00 00 + 8字節版本數據
            firmware_type = result['response_data'][2] | (result['response_data'][3] << 8)
            major_version = result['response_data'][4] | (result['response_data'][5] << 8)
            minor_version_bytes = result['response_data'][6:10]
            minor_version = int.from_bytes(minor_version_bytes, 'little')
            
            result['firmware_type'] = f"0x{firmware_type:04X}"
            result['major_version'] = f"{major_version >> 8}.{major_version & 0xFF}"
            result['minor_version'] = str(minor_version)
            result['full_version'] = f"V{result['major_version']}.{result['minor_version']}"
    
    elif command_code == 0xA5:  # MAC地址查詢
        if len(result['response_data']) >= 6:
            mac_bytes = result['response_data'][:6]
            result['mac_address'] = ':'.join(f'{b:02X}' for b in mac_bytes)
    
    elif command_code == 0x0113:  # 移動門敏感度查詢 (回應碼)
        if len(result['response_data']) >= 16:  # 修正：1字節執行狀態 + 1字節ACK + 14字節敏感度數據
            exec_status = result['response_data'][0]
            ack_status = result['response_data'][1]
            result['exec_status'] = exec_status
            result['ack_status'] = ack_status
            result['ack_success'] = ack_status == 0x00
            # 修正關鍵：門0敏感度在第2字節位置，門1-13在第3-15字節位置
            gate_sensitivities = []
            gate_sensitivities.append(result['response_data'][2])  # 門0
            gate_sensitivities.extend(result['response_data'][3:16])  # 門1-13
            result['moving_gate_sensitivities'] = gate_sensitivities
    
    elif command_code == 0x0114:  # 靜止門敏感度查詢 (回應碼)
        if len(result['response_data']) >= 16:  # 修正：1字節執行狀態 + 1字節ACK + 14字節敏感度數據
            exec_status = result['response_data'][0]
            ack_status = result['response_data'][1]
            result['exec_status'] = exec_status
            result['ack_status'] = ack_status
            result['ack_success'] = ack_status == 0x00
            # 修正關鍵：門0敏感度在第2字節位置，門1-13在第3-15字節位置
            gate_sensitivities = []
            gate_sensitivities.append(result['response_data'][2])  # 門0
            gate_sensitivities.extend(result['response_data'][3:16])  # 門1-13
            result['still_gate_sensitivities'] = gate_sensitivities
    
    elif command_code == 0x11:  # 距離分辨率查詢
        if len(result['response_data']) >= 8:  # 00 00 + 6字節分辨率數據
            resolution_value = result['response_data'][2]
            resolution_map = {
                0x00: "75cm/距離門 (12米範圍)",
                0x01: "50cm/距離門 (8米範圍)", 
                0x03: "20cm/距離門 (3.2米範圍)"
            }
            result['resolution_value'] = resolution_value
            result['resolution_description'] = resolution_map.get(resolution_value, f"未知分辨率 0x{resolution_value:02X}")
    
    elif command_code == 0xFF:  # 進入配置模式
        if len(result['response_data']) >= 6:  # 00 00 + 協議版本等數據
            protocol_version = result['response_data'][2] | (result['response_data'][3] << 8)
            result['protocol_version'] = f"v{protocol_version >> 8}.{protocol_version & 0xFF}"
    
    elif command_code == 0x12:  # 參數查詢
        if len(result['response_data']) >= 7:  # 00 00 + 5字節參數數據
            result['min_distance_gate'] = result['response_data'][2]
            result['max_distance_gate'] = result['response_data'][3]
            result['timeout'] = result['response_data'][4] | (result['response_data'][5] << 8)
            result['out_pin_polarity'] = result['response_data'][6]
            result['out_pin_description'] = "有人輸出高電平" if result['response_data'][6] == 0 else "有人輸出低電平"
    
    elif command_code == 0x1C:  # 光感輔助控制功能配置查詢
        if len(result['response_data']) >= 4:  # 00 00 + 配置數據2字節
            control_mode = result['response_data'][2]
            light_threshold = result['response_data'][3]
            
            mode_description = {
                0x00: "關閉光感輔助控制功能",
                0x01: "光感值小於閾值時輔助控制條件滿足",
                0x02: "光感值大於閾值時輔助控制條件滿足"
            }
            
            result['light_control_mode'] = control_mode
            result['light_threshold'] = light_threshold
            result['mode_description'] = mode_description.get(control_mode, f"未知模式 0x{control_mode:02X}")
    
    elif command_code == 0x1B:  # 背景校正狀態查詢
        if len(result['response_data']) >= 4:  # 00 00 + 狀態數據2字節
            status_value = result['response_data'][2] | (result['response_data'][3] << 8)
            
            result['calibration_status'] = status_value
            result['calibration_active'] = status_value == 0x0001
            result['status_description'] = "正在執行動態背景校正中" if status_value == 0x0001 else "未在執行動態背景校正"
    
    return result, "命令解析成功"
```

### 4. 完整數據解析
```python
def parse_ld2412_frame(frame):
    """完整解析LD2412數據幀"""
    validation_result = validate_data_frame(frame)
    if not validation_result[0]:
        return None, validation_result[1]
    
    # 基本信息
    frame_length = struct.unpack('<H', frame[4:6])[0]
    data_type = frame[6]
    checksum = frame[7]
    target_state = frame[8]
    
    # 移動目標信息
    moving_distance = struct.unpack('<H', frame[9:11])[0]
    moving_energy = frame[11]
    
    # 靜止目標信息  
    still_distance = struct.unpack('<H', frame[12:14])[0]
    still_energy = frame[14]
    
    result = {
        'frame_length': frame_length,
        'data_type': data_type,
        'data_type_name': '工程模式' if data_type == 0x01 else '一般模式',
        'checksum': checksum,
        'target_state': parse_target_state(target_state),
        'moving_distance': moving_distance,
        'moving_energy': moving_energy,
        'still_distance': still_distance,
        'still_energy': still_energy
    }
    
    # 工程模式額外數據
    if data_type == 0x01 and len(frame) >= 53:
        moving_gates = frame[15]  # 0D = 13 (代表0-13共14門)
        still_gates = frame[16]   # 0D = 13 (代表0-13共14門)
        
        # 各門能量數據
        moving_gate_energies = list(frame[17:31])  # 14門
        still_gate_energies = list(frame[31:45])   # 14門
        light_sensor = frame[45]
        reserved1 = frame[46]
        tail_marker = frame[47]  # 應該是0x55
        reserved2 = frame[48]
        
        result.update({
            'moving_gates_count': moving_gates,
            'still_gates_count': still_gates,
            'moving_gate_energies': moving_gate_energies,
            'still_gate_energies': still_gate_energies,
            'light_sensor': light_sensor,
            'tail_marker': tail_marker,
            'reserved1': reserved1,
            'reserved2': reserved2
        })
    elif data_type == 0x02:
        # 一般模式
        tail_marker = frame[15]  # 應該是0x55
        reserved = frame[16]
        
        result.update({
            'tail_marker': tail_marker,
            'reserved': reserved
        })
    
    return result, "解析成功"
```

## 🚨 重要注意事項

### 1. 命令執行順序
```
⚠️ 必須按順序執行：
1. 進入配置模式 (FF 00)
2. 執行配置命令
3. 退出配置模式 (FE 00)  
4. 查詢參數啟動數據輸出 (12 00)
```

### 2. 時序要求
- 命令間隔：建議500-800ms
- ACK等待：最多1秒超時
- 配置生效：退出配置模式後生效
- 重啟後重新初始化
- 工程模式切換需要在配置模式下執行

### 3. 錯誤處理策略
- 無效命令：不會有回應，需重試
- 未進配置模式：配置命令無效
- 通信中斷：重新初始化序列
- 波特率改變：需調整串口設定並重啟模組

### 4. 數據同步建議
- 使用幀頭同步：`F4 F3 F2 F1` (數據) / `FD FC FB FA` (命令)
- 驗證幀尾：`F8 F7 F6 F5` (數據) / `04 03 02 01` (命令)
- 檢查長度字段一致性
- 實現環形緩衝區處理
- 門數量：0D代表0-13共14門
- 命令回應格式：第6字節=命令碼，第7字節=狀態(01=成功)

### 5. 特殊注意事項
- **查詢參數命令 (0x12)** 同時具有啟動數據輸出的功能
- **工程模式** 必須在配置模式下切換
- **敏感度查詢** 返回的第一個字節是保留位，實際敏感度從第二個字節開始
- **距離分辨率** 影響最大檢測距離和精度
- **動態背景校正** 需要約2分鐘完成，期間建議避免移動

## 📊 效能參數

| 參數 | 數值 | 說明 |
|------|------|------|
| **檢測距離** | 0-12米 | 可配置最大距離 |
| **距離精度** | ±0.2-0.75米 | 可設定分辨率 |
| **距離分辨率** | 0.2m/0.5m/0.75m | 三種模式 |
| **檢測角度** | ±60° | 水平檢測範圍 |
| **更新頻率** | ~10Hz | 約100ms間隔 |
| **距離門數** | 14門 | 0-13號距離門 |
| **能量範圍** | 0-100 | 檢測敏感度 |
| **功耗** | <200mA | @3.3V供電 |
| **光感範圍** | 0-255 | 0x00-0xFF |

## 🔗 相關資源

- **官方規格**: [LD2412產品頁面](https://www.hlktech.net/index.php?id=988)
- **GitHub項目**: [Rihan9/LD2412](https://github.com/Rihan9/LD2412)
- **ESP Home組件**: [LD2412 Component](https://github.com/Rihan9/LD2412/tree/main/components/LD2412)
- **本專案工具**:
  - ESP8266範例: `src/main.cpp`
  - Python GUI: `ld2412_dark_gui.py`
  - 命令行工具: `ld2412_cli.py`
  - 數據分析: `ld2412_analyzer.py`

---

**文檔版本**: v2.6  
**最後更新**: 2024年1月  
**適用型號**: LD2412, LD2410系列  
**維護者**: LD2412測試專案組  
**驗證工具**: ld2412_dark_gui.py  
**重要修正**: 
- 🚨 **關鍵修正**: 門敏感度查詢回應解析格式
  - 修正移動門和靜止門敏感度查詢的數據格式說明
  - **門0敏感度位於回應數據的第3字節，不是保留字節！**
  - 正確的解析位置：位置10=門0，位置11-23=門1-13
  - 此修正解決了門0敏感度被錯誤顯示的重大問題
- 更新命令回應解析函數，使用正確的小端序命令碼解析
- 添加實際測試案例分析和常見錯誤說明
- 更新Python調試工具函數以反映正確的解析邏輯

**舊版更新內容**: 
- 添加光感輔助控制功能配置查詢命令(0x1C)
- 更新版本查詢命令回應格式
- 更新背景校正狀態查詢回應格式
- 添加出廠默認配置值詳細說明
- 完善波特率設置命令說明
- 修正所有查詢命令回應格式 (添加00 00 ACK狀態前綴)
- 添加基礎參數配置命令(0x0002)
- 添加運動靈敏度配置命令(0x0003)
- 添加靜止靈敏度配置命令(0x0004)
- 更新進入配置模式命令回應格式
- 完善動態背景校正命令說明
- 更新Python解析函數支持新格式

## 🔧 重要修正案例說明

### 門0敏感度解析錯誤修正 (v2.6)

**問題描述**: 
在之前的實現中，門0敏感度查詢總是顯示為錯誤的值（通常顯示為100而實際應該是0）。

**問題根因**:
誤將敏感度查詢回應中的第10字節（門0敏感度）識別為"保留字節"，導致門0敏感度被錯誤地解析為門1的敏感度值。

**實際測試數據分析**:
```
原始幀: FD FC FB FA 12 00 14 01 00 00 00 64 23 19 0F 0F 0F...
位置分析:
- 第8字節(01): 執行狀態 = 成功
- 第9字節(00): ACK狀態 = 成功  
- 第10字節(00): 門0敏感度 = 0 (之前被誤認為保留字節)
- 第11字節(64): 門1敏感度 = 100 (之前被錯誤當作門0)
- 第12字節以後: 門2-13敏感度值
```

**修正前後對比**:
```python
# 錯誤的舊實現
ack_status = frame[9] | (frame[10] << 8)  # 錯誤地將門0敏感度當作ACK高位
sens_data_start = 11  # 錯誤地跳過了門0敏感度
sens_values = frame[11:25]  # 缺失門0，實際是門1-14

# 正確的新實現  
ack_status = frame[9]  # 正確的ACK狀態
gate0_sensitivity = frame[10]  # 門0敏感度
gate1_13_sensitivities = frame[11:24]  # 門1-13敏感度
sens_values = [gate0_sensitivity] + list(gate1_13_sensitivities)
```

**驗證方法**:
1. 使用實際設備進行敏感度查詢
2. 檢查門0敏感度是否正確顯示為設定值（而非其他門的值）
3. 確認所有14個門的敏感度值都正確對應

**影響範圍**:
此修正影響所有使用LD2412門敏感度查詢功能的代碼，請檢查並更新：
- 移動門敏感度查詢解析 (0x0113)
- 靜止門敏感度查詢解析 (0x0114)
- 相關的GUI顯示和數據處理邏輯